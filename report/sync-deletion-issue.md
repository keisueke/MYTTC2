# 同期時に削除アイテムが復活する問題の調査と改修案

## 1. 問題の概要
ユーザーより「GitHubやCloudflareと同期をとる時に、削除したアイテムが元に戻っていることが多い」との報告がありました。
当初、物理削除（完全消去）と同期ロジック（存在しないものは新規扱い）の不整合が原因と考え論理削除を導入しましたが、その後「リロードすると削除が戻る」という現象が継続して報告されました。

再調査の結果、**同期処理中のデータ競合（Race Condition）**が根本原因の一つであることが判明しました。

## 2. 原因の詳細

### A. 物理削除の不整合（一次調査で判明）
*   **現象**: ローカルでデータを消しても、サーバーに残っているデータが「新規データ」として認識され、書き戻される。
*   **対策**: 論理削除（`deletedAt`フラグ）を導入済み。

### B. 同期中のデータ競合（二次調査で判明）
*   **現象**: 同期処理（特にネットワーク通信に時間がかかる場合）の最中にユーザーが削除操作を行うと、その変更が失われる。
*   **メカニズム**:
    1.  同期開始時、その時点のローカルデータを取得（スナップショットA）。
    2.  リモートデータを取得（通信待ち）。
    3.  **この間にユーザーが削除操作を行う（スナップショットBに変化）。**
    4.  同期処理が、リモートデータと**スナップショットA**をマージし、保存する。
    5.  結果、スナップショットBで行われた削除操作が、スナップショットA（削除前）で上書きされて無効化される。

## 3. 改修内容

### Phase 1: 論理削除の導入（完了）
*   全主要エンティティ（Task, Project等）に `deletedAt` を追加。
*   `taskService` の削除処理を論理削除に変更し、取得処理でフィルタリングを実装。

### Phase 2: 同期ロジックの修正（完了）
*   `useCloudflare.ts` のマージロジックをタイムスタンプベースに統一。

### Phase 3: データ競合の解消（今回実施）
*   `useCloudflare.ts` および `useGitHub.ts` の同期処理（`syncBidirectional`）を修正。
*   **リモートデータ取得完了後、マージや保存を行う直前に、再度ローカルデータ（最新状態）を読み込むように変更。**
*   これにより、同期中にユーザーが行った操作（削除、追加、更新）を取りこぼすことなく、最新の状態でマージが行われるようになります。

## 4. 検証結果
*   コード修正後のビルド（`npm run build`）が成功することを確認済み。
*   同期処理のクリティカルなタイミングでの再読み込み処理が実装されたため、リロードやバックグラウンド同期時の「削除復活」は解消される見込みです。

## 5. 推奨アクション
本改修により、削除操作の信頼性は大幅に向上しています。まずは通常の利用で問題が再発しないか様子を見ていただき、万が一再発する場合は「どのタイミング（操作直後、しばらくして、別端末操作後など）」かを特定いただければ幸いです。
