# 同期時に削除アイテムが復活する問題の調査と改修案

## 1. 問題の概要
ユーザーより「GitHubやCloudflareと同期をとる時に、削除したアイテムが元に戻っていることが多い」との報告がありました。
当初、物理削除（完全消去）と同期ロジック（存在しないものは新規扱い）の不整合が原因と考え論理削除を導入しましたが、その後「リロードすると削除が戻る」という現象が継続して報告されました。特にルーティンタスクで顕著でした。

徹底的な再調査の結果、以下の3つの複合的な要因が特定されました。

1.  **物理削除の不整合**（一次調査で判明、対応済み）
2.  **同期中のデータ競合**（二次調査で判明、対応済み）
3.  **ルーティン自動生成ロジックの不備**（三次調査で判明、対応済み）

## 2. 原因の詳細

### A. 物理削除の不整合（一次調査）
*   **現象**: 同期時に「データが存在しない＝新規追加」と判定され、サーバーから削除済みデータが復活する。
*   **対策**: 論理削除（`deletedAt`フラグ）を導入。

### B. 同期中のデータ競合（二次調査）
*   **現象**: 同期処理中に削除操作を行うと、マージ時に古い状態で上書きされる。
*   **対策**: 同期マージ直前にローカルデータを再取得するよう修正。

### C. ルーティン自動生成ロジックの不備（三次調査：今回の主原因）
*   **現象**: ルーティンタスクを削除しても、ルーティン生成ロジックが**削除フラグ（`deletedAt`）を無視**して、再度「今日のタスク」や「実行記録」を生成してしまう。
    *   `ensureTodayRoutineExecutions`: 削除済みルーティンに対しても実行記録を作成してしまう。
    *   `ensureTodayRepeatTasks`: 削除済みルーティンから新しい日次タスクを作成してしまう。
    *   `processIncompleteTasksFromYesterday`: 昨日の未完了タスク処理で、削除済みタスクを「スキップ」として復活させてしまう。
*   **結果**: ユーザーが削除ボタンを押しても、システムが自動的に「復活」させていた。

## 3. 改修内容

### Phase 1: 論理削除の導入（完了）
*   全主要エンティティに `deletedAt` を追加し、サービス層の基本操作を改修。

### Phase 2: 同期ロジックの修正（完了）
*   マージロジックをタイムスタンプベースに統一。
*   同期競合（Race Condition）対策としてデータ再取得処理を追加。

### Phase 3: ルーティンロジックの修正（完了）
*   `src/services/taskService.ts` 内の以下の関数を修正し、`deletedAt` が設定されているタスクを完全に無視するように変更。
    *   `ensureTodayRoutineExecutions`
    *   `ensureTodayRepeatTasks`
    *   `processIncompleteTasksFromYesterday`

## 4. 検証結果
*   ビルド（`npm run build`）成功。
*   これにより、ルーティンタスクを削除した場合、二度とそのタスクに基づいた自動生成は行われなくなります。

## 5. ユーザーへの回答
**Q: ルーティンは削除ではなく、そのままが適切でしょうか？**

A: **いいえ、削除で問題ありません。**
これまではシステムの不具合により、「削除したはずなのにシステムが勝手に作り直してしまう」状態でした。今回の修正により、「削除」ボタンを押せば、そのルーティン設定自体が論理的に削除され、今後新しいタスクが生成されることはなくなります。「今日の分だけ消したい」ではなく「ルーティン自体をやめたい」場合は、削除ボタンを押してください。システムはそれを正しく尊重するようになります。
